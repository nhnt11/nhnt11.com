<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Nihanth Subramanya</title>
    <link rel="stylesheet" href="styles.css"/>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Technologist, photographer, writer"/>
  </head>
  <body class="index-body page-loading">
    <div class="loading-spinner"></div>
    <div class="bg-layer bg-layer-1 active"></div>
    <div class="bg-layer bg-layer-2"></div>
    <div class="vignette vignette-top-left"></div>
    <div class="vignette vignette-bottom-right"></div>
    <div class="name-container">
      <span class="h1">Nihanth<br>Subramanya</span>
    </div>
    <nav class="nav-links">
      <a href="https://www.x.com/nhnt11" target="_blank" rel="noopener">X</a>
      <a href="https://nhnt11.medium.com/" target="_blank" rel="noopener">Blog</a>
      <a href="https://www.instagram.com/imprintsofspacetime" target="_blank" rel="noopener">Photos</a>
      <a href="https://www.linkedin.com/in/nhnt11" target="_blank" rel="noopener">Work</a>
    </nav>
    <script>
      // ==================================================
      // CONSTANTS
      // ==================================================

      const TIMING = {
        transitionSlow: 1500,   // ms - crossfade between images
        transitionFast: 500,    // ms - user-initiated image switches
        cyclePause: 5000,       // ms - time between auto-advances
        parallaxSmooth: 500,    // ms - smooth first parallax move
      };

      const LAYOUT = {
        vignettePadding: 250,   // px - breathing room around text
        parallaxDeadzone: 50,   // px - edge area where parallax stops
        tapEdgeZone: 0.15,      // fraction - edge tap to change image
        tapThreshold: 10,       // px - movement before tap becomes pan
        minOverflow: 1.15,      // fraction - minimum image overflow for parallax
        maxOverflow: 1.35,      // fraction - target overflow on larger dimension
        panSpeedX: 0.0008,      // fraction/ms - horizontal pan speed on mobile
      };

      const IMAGES = [
        'https://cdn.nhnt11.com/bg-tuscany.jpg',
        'https://cdn.nhnt11.com/DSC02365-Edit-Edit-2.jpg',
        'https://cdn.nhnt11.com/DSC02426-Edit-2.jpg',
        'https://cdn.nhnt11.com/DSC02446-Edit.jpg',
        'https://cdn.nhnt11.com/DSC02928-Edit.jpg',
        'https://cdn.nhnt11.com/DSC02978-Edit-2.jpg',
        'https://cdn.nhnt11.com/DSC03498-Edit-2.jpg',
        'https://cdn.nhnt11.com/DSC05664-Edit.jpg',
        'https://cdn.nhnt11.com/DSC07910.jpg',
        'https://cdn.nhnt11.com/DSC07914.jpg',
        'https://cdn.nhnt11.com/DSC08059.jpg',
      ];

      // ==================================================
      // DOM ELEMENTS
      // ==================================================

      const DOM = {
        body: document.body,
        nameContainer: document.querySelector('.name-container'),
        navLinks: document.querySelector('.nav-links'),
        vignetteTL: document.querySelector('.vignette-top-left'),
        vignetteBR: document.querySelector('.vignette-bottom-right'),
        bgLayer1: document.querySelector('.bg-layer-1'),
        bgLayer2: document.querySelector('.bg-layer-2'),
      };

      // ==================================================
      // VIGNETTE - Dynamic sizing around content
      // ==================================================

      const Vignette = (function() {
        function update() {
          const padding = LAYOUT.vignettePadding;
          const nameRect = DOM.nameContainer.getBoundingClientRect();
          const navRect = DOM.navLinks.getBoundingClientRect();

          // Top-left vignette: double size so center sits at corner
          const tlWidth = (nameRect.width + nameRect.left + padding) * 2;
          const tlHeight = (nameRect.height + nameRect.top + padding) * 2;
          DOM.vignetteTL.style.width = tlWidth + 'px';
          DOM.vignetteTL.style.height = tlHeight + 'px';
          DOM.vignetteTL.style.top = '0';
          DOM.vignetteTL.style.left = '0';

          // Bottom-right vignette: double size so center sits at corner
          const brWidth = (navRect.width + (window.innerWidth - navRect.right) + padding) * 2;
          const brHeight = (navRect.height + (window.innerHeight - navRect.bottom) + padding) * 2;
          DOM.vignetteBR.style.width = brWidth + 'px';
          DOM.vignetteBR.style.height = brHeight + 'px';
          DOM.vignetteBR.style.bottom = '0';
          DOM.vignetteBR.style.right = '0';
        }

        return { update };
      })();

      // ==================================================
      // GALLERY - Background image cycling and preloading
      // ==================================================

      const Gallery = (function() {
        // --------------------------------------------------
        // State
        // --------------------------------------------------
        let currentIndex = 0;
        let activeLayer = DOM.bgLayer1;
        let isTransitioning = false;
        let cycleIntervalId = null;
        const imageData = [];  // stores { width, height } for each image
        const onCycleCallbacks = [];

        // --------------------------------------------------
        // Private functions
        // --------------------------------------------------

        function preloadImage(index) {
          return new Promise((resolve) => {
            if (imageData[index]) {
              resolve(imageData[index]);
              return;
            }
            const img = new Image();
            img.onload = function() {
              imageData[index] = { width: this.naturalWidth, height: this.naturalHeight };
              resolve(imageData[index]);
            };
            img.onerror = () => resolve(null);
            img.src = IMAGES[index];
          });
        }

        function preloadAllImages() {
          IMAGES.forEach((_, index) => preloadImage(index));
        }

        function calculateBackgroundSize(imgWidth, imgHeight) {
          const viewWidth = window.innerWidth;
          const viewHeight = window.innerHeight;
          const imgAspect = imgWidth / imgHeight;
          const viewAspect = viewWidth / viewHeight;

          let finalWidth, finalHeight;

          if (imgAspect >= viewAspect) {
            // Width overflows more - target max overflow on width
            finalWidth = viewWidth * LAYOUT.maxOverflow;
            finalHeight = finalWidth / imgAspect;
            // Ensure minimum overflow on height
            if (finalHeight < viewHeight * LAYOUT.minOverflow) {
              finalHeight = viewHeight * LAYOUT.minOverflow;
              finalWidth = finalHeight * imgAspect;
            }
          } else {
            // Height overflows more - target max overflow on height
            finalHeight = viewHeight * LAYOUT.maxOverflow;
            finalWidth = finalHeight * imgAspect;
            // Ensure minimum overflow on width
            if (finalWidth < viewWidth * LAYOUT.minOverflow) {
              finalWidth = viewWidth * LAYOUT.minOverflow;
              finalHeight = finalWidth / imgAspect;
            }
          }

          return `${finalWidth}px ${finalHeight}px`;
        }

        function setLayerImage(layer, index) {
          const src = IMAGES[index];
          const data = imageData[index];
          layer.style.backgroundImage = `url('${src}')`;
          if (data) {
            layer.style.backgroundSize = calculateBackgroundSize(data.width, data.height);
          }
        }

        function updateAllBackgroundSizes() {
          [DOM.bgLayer1, DOM.bgLayer2].forEach((layer) => {
            const layerIndex = layer === activeLayer ? currentIndex : (currentIndex + 1) % IMAGES.length;
            const data = imageData[layerIndex];
            if (data) {
              layer.style.backgroundSize = calculateBackgroundSize(data.width, data.height);
            }
          });
        }

        // --------------------------------------------------
        // Public API
        // --------------------------------------------------

        function cycle(direction = 1, fast = false) {
          if (IMAGES.length <= 1 || isTransitioning) return;

          const nextIndex = (currentIndex + direction + IMAGES.length) % IMAGES.length;
          const inactiveLayer = activeLayer === DOM.bgLayer1 ? DOM.bgLayer2 : DOM.bgLayer1;
          const duration = fast ? TIMING.transitionFast : TIMING.transitionSlow;

          isTransitioning = true;

          preloadImage(nextIndex).then(() => {
            setLayerImage(inactiveLayer, nextIndex);
            inactiveLayer.style.backgroundPosition = activeLayer.style.backgroundPosition;

            if (fast) {
              DOM.bgLayer1.style.transitionDuration = `${duration}ms`;
              DOM.bgLayer2.style.transitionDuration = `${duration}ms`;
            }

            activeLayer.classList.remove('active');
            inactiveLayer.classList.add('active');

            activeLayer = inactiveLayer;
            currentIndex = nextIndex;
            localStorage.setItem('lastBgIndex', currentIndex);

            // Preload next image in line
            preloadImage((currentIndex + 1) % IMAGES.length);

            // Notify listeners
            onCycleCallbacks.forEach(cb => cb());

            setTimeout(() => {
              isTransitioning = false;
              if (fast) {
                DOM.bgLayer1.style.transitionDuration = '';
                DOM.bgLayer2.style.transitionDuration = '';
              }
            }, duration);
          });
        }

        function resetTimer() {
          if (cycleIntervalId) {
            clearInterval(cycleIntervalId);
          }
          if (IMAGES.length > 1) {
            cycleIntervalId = setInterval(() => cycle(1), TIMING.cyclePause);
          }
        }

        function setPosition(x, y) {
          const position = `${x}% ${y}%`;
          DOM.bgLayer1.style.backgroundPosition = position;
          DOM.bgLayer2.style.backgroundPosition = position;
        }

        function setTransition(value) {
          DOM.bgLayer1.style.transition = value;
          DOM.bgLayer2.style.transition = value;
        }

        function onCycle(callback) {
          onCycleCallbacks.push(callback);
        }

        function init() {
          const lastIndex = localStorage.getItem('lastBgIndex');
          if (lastIndex !== null) {
            currentIndex = (parseInt(lastIndex, 10) + 1) % IMAGES.length;
          } else {
            currentIndex = Math.floor(Math.random() * IMAGES.length);
          }
          localStorage.setItem('lastBgIndex', currentIndex);

          return preloadImage(currentIndex).then(() => {
            setLayerImage(DOM.bgLayer1, currentIndex);
            DOM.bgLayer1.style.backgroundPosition = '50% 50%';
            DOM.body.classList.remove('page-loading');
            preloadAllImages();
            resetTimer();
          });
        }

        return {
          cycle,
          resetTimer,
          setPosition,
          setTransition,
          onCycle,
          init,
          updateSizes: updateAllBackgroundSizes,
          isTransitioning: () => isTransitioning,
          getCurrentIndex: () => currentIndex,
          getImageData: (index) => imageData[index],
        };
      })();

      // ==================================================
      // PARALLAX - Mouse-based background movement (desktop)
      // ==================================================

      const Parallax = (function() {
        let isFirstMove = true;

        function handleMouseMove(e) {
          const padding = LAYOUT.parallaxDeadzone;
          const viewWidth = window.innerWidth;
          const viewHeight = window.innerHeight;

          const clampedX = Math.max(padding, Math.min(viewWidth - padding, e.clientX));
          const clampedY = Math.max(padding, Math.min(viewHeight - padding, e.clientY));

          const percentX = ((clampedX - padding) / (viewWidth - 2 * padding)) * 100;
          const percentY = ((clampedY - padding) / (viewHeight - 2 * padding)) * 100;

          // Smooth transition on first mouse entry to prevent jerk
          if (isFirstMove) {
            isFirstMove = false;
            Gallery.setTransition(`opacity ${TIMING.transitionSlow}ms ease-in-out, background-position ${TIMING.parallaxSmooth}ms ease-out`);
            setTimeout(() => Gallery.setTransition(''), TIMING.parallaxSmooth);
          }

          Gallery.setPosition(percentX, percentY);
        }

        function init() {
          document.addEventListener('mousemove', handleMouseMove);
        }

        return { init };
      })();

      // ==================================================
      // PAN - Touch-based panning and auto-pan (mobile)
      // ==================================================

      const Pan = (function() {
        // --------------------------------------------------
        // State
        // --------------------------------------------------
        let animationId = null;
        let startTime = null;
        let params = null;
        let currentX = 50;
        let currentY = 50;
        let isTouching = false;

        // Touch state
        let touchStartX = 0;
        let touchStartY = 0;
        let panStartX = 0;
        let panStartY = 0;
        let hasPanned = false;
        let wasRevealedBeforePan = false;

        // --------------------------------------------------
        // Auto-pan animation
        // --------------------------------------------------

        function initParams(isFirst) {
          const data = Gallery.getImageData(Gallery.getCurrentIndex());
          if (!data) return null;

          const direction = Math.random() < 0.5 ? 1 : -1;
          const angleOffset = (Math.random() - 0.5) * 30;  // -15 to +15 degrees
          const angleRad = angleOffset * Math.PI / 180;

          return {
            direction,
            speedX: LAYOUT.panSpeedX,
            speedY: LAYOUT.panSpeedX * Math.tan(angleRad),
            startX: isFirst ? 50 : currentX,
            startY: isFirst ? 50 : currentY
          };
        }

        function updatePosition() {
          Gallery.setPosition(currentX, currentY);
        }

        function animate(timestamp) {
          if (!startTime) startTime = timestamp;
          if (!params) {
            params = initParams(true);
            if (!params) {
              animationId = requestAnimationFrame(animate);
              return;
            }
          }

          const elapsed = timestamp - startTime;
          const deltaX = elapsed * params.speedX * params.direction;
          const deltaY = elapsed * params.speedY * params.direction;

          currentX = Math.max(0, Math.min(100, params.startX + deltaX));
          currentY = Math.max(0, Math.min(100, params.startY + deltaY));

          updatePosition();
          animationId = requestAnimationFrame(animate);
        }

        function startNewPan(isFirst) {
          startTime = null;
          params = initParams(isFirst);
          if (animationId) cancelAnimationFrame(animationId);
          animationId = requestAnimationFrame(animate);
        }

        // --------------------------------------------------
        // Touch handlers
        // --------------------------------------------------

        function handleTouchStart(e) {
          if (e.touches.length !== 1) return;
          if (e.target.closest('a, button')) return;

          isTouching = true;
          hasPanned = false;
          wasRevealedBeforePan = DOM.body.classList.contains('bg-reveal');
          touchStartX = e.touches[0].clientX;
          touchStartY = e.touches[0].clientY;
          panStartX = currentX;
          panStartY = currentY;

          // Disable background-position transition for immediate response
          Gallery.setTransition(`opacity ${TIMING.transitionSlow}ms ease-in-out`);

          if (animationId) {
            cancelAnimationFrame(animationId);
            animationId = null;
          }
        }

        function handleTouchMove(e) {
          if (!isTouching || e.touches.length !== 1) return;
          e.preventDefault();  // Prevent pull-to-refresh

          const touchX = e.touches[0].clientX;
          const touchY = e.touches[0].clientY;

          if (!hasPanned) {
            const pixelDeltaX = Math.abs(touchX - touchStartX);
            const pixelDeltaY = Math.abs(touchY - touchStartY);
            if (pixelDeltaX > LAYOUT.tapThreshold || pixelDeltaY > LAYOUT.tapThreshold) {
              hasPanned = true;
              DOM.body.classList.add('bg-reveal');
            }
          }

          // Convert pixel movement to percentage (invert for natural drag)
          const deltaX = ((touchStartX - touchX) / window.innerWidth) * 100;
          const deltaY = ((touchStartY - touchY) / window.innerHeight) * 100;

          currentX = Math.max(0, Math.min(100, panStartX + deltaX));
          currentY = Math.max(0, Math.min(100, panStartY + deltaY));

          updatePosition();
        }

        function handleTouchEnd() {
          if (!isTouching) return;
          isTouching = false;

          Gallery.setTransition('');

          if (hasPanned) {
            if (wasRevealedBeforePan) {
              DOM.body.classList.add('bg-reveal');
            } else {
              DOM.body.classList.remove('bg-reveal');
            }
          } else {
            // Tap: check if on left/right edge to cycle background
            const edgeZone = window.innerWidth * LAYOUT.tapEdgeZone;
            if (touchStartX < edgeZone) {
              if (!Gallery.isTransitioning()) {
                Gallery.cycle(-1, true);
                Gallery.resetTimer();
              }
            } else if (touchStartX > window.innerWidth - edgeZone) {
              if (!Gallery.isTransitioning()) {
                Gallery.cycle(1, true);
                Gallery.resetTimer();
              }
            } else {
              DOM.body.classList.toggle('bg-reveal');
            }
          }

          startNewPan(false);
        }

        // --------------------------------------------------
        // Public API
        // --------------------------------------------------

        function init() {
          document.addEventListener('touchstart', handleTouchStart, { passive: true });
          document.addEventListener('touchmove', handleTouchMove, { passive: false });
          document.addEventListener('touchend', handleTouchEnd);
          document.addEventListener('touchcancel', handleTouchEnd);

          // Start panning after image cycles
          Gallery.onCycle(function() {
            if (!isTouching) startNewPan(false);
          });

          // Wait for initial image data before starting
          const checkAndStart = setInterval(() => {
            if (Gallery.getImageData(Gallery.getCurrentIndex())) {
              clearInterval(checkAndStart);
              startNewPan(true);
            }
          }, 100);
        }

        return {
          init,
          isTouching: () => isTouching,
        };
      })();

      // ==================================================
      // KEYBOARD - Navigation shortcuts
      // ==================================================

      const Keyboard = (function() {
        function handleKeydown(e) {
          if (e.key === 'ArrowRight') {
            if (!Gallery.isTransitioning()) {
              Gallery.cycle(1, true);
              Gallery.resetTimer();
            }
          } else if (e.key === 'ArrowLeft') {
            if (!Gallery.isTransitioning()) {
              Gallery.cycle(-1, true);
              Gallery.resetTimer();
            }
          }
        }

        function init() {
          document.addEventListener('keydown', handleKeydown);
        }

        return { init };
      })();

      // ==================================================
      // CLICK REVEAL - Desktop background reveal on click
      // ==================================================

      const ClickReveal = (function() {
        function handleClick(e) {
          if (e.target.closest('a, button, input, textarea, select')) return;
          DOM.body.classList.toggle('bg-reveal');
        }

        function init() {
          document.addEventListener('click', handleClick);
        }

        return { init };
      })();

      // ==================================================
      // INITIALIZATION
      // ==================================================

      Vignette.update();
      window.addEventListener('resize', Vignette.update);
      window.addEventListener('resize', Gallery.updateSizes);

      Gallery.init().then(() => {
        Keyboard.init();

        // Device-specific interactions
        const hasPointer = window.matchMedia('(pointer: fine)').matches;
        if (hasPointer) {
          Parallax.init();
          ClickReveal.init();
        } else {
          Pan.init();
        }
      });
    </script>
  </body>
</html>
