<!DOCTYPE html>
<html lang="en">
  <head>
    <title>dream</title>
    <link rel="stylesheet" href="../styles.css"/>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
  </head>
  <body class="dream-body">
    <!-- WebGL background -->
    <canvas class="dream-bg" id="psychedelic-canvas"></canvas>

    <!-- Debug overlay -->
    <div id="debug" class="dream-debug" style="display: none;">
      <div id="debug-content"></div>
    </div>

    <!-- Overlay with text -->
    <div class="dream-overlay">
      <div class="dream-text-container">
        <span class="dream-text">dream</span>
        <span class="dream-slice" data-slice="0">dream</span>
        <span class="dream-slice" data-slice="1">dream</span>
        <span class="dream-slice" data-slice="2">dream</span>
        <span class="dream-slice" data-slice="3">dream</span>
      </div>
    </div>

    <script>
      // ===================
      // GLITCH TEXT LOGIC
      // ===================
      const container = document.querySelector('.dream-text-container');
      const slices = document.querySelectorAll('.dream-slice');

      const fonts = [
        "'Rubik Glitch', system-ui",
        "'Shrikhand', system-ui",
        "'Fascinate Inline', system-ui"
      ];

      container.style.fontFamily = fonts[Math.floor(Math.random() * fonts.length)];

      let isGlitching = false;

      function triggerGlitch(allowFontChange = true, scheduleNext = true) {
        if (isGlitching) return;
        isGlitching = true;

        if (allowFontChange && Math.random() < 0.5) {
          container.style.fontFamily = fonts[Math.floor(Math.random() * fonts.length)];
        }

        slices.forEach(slice => {
          if (Math.random() > 0.3) {
            slice.style.setProperty('--glitch-x', `${(Math.random() - 0.5) * 60}px`);
            slice.style.setProperty('--glitch-skew', `${(Math.random() - 0.5) * 10}deg`);
            slice.classList.add('glitching');
          }
        });

        container.classList.add('glitching');

        setTimeout(() => {
          container.classList.remove('glitching');
          slices.forEach(slice => slice.classList.remove('glitching'));
          isGlitching = false;
          if (scheduleNext) scheduleNextGlitch();
        }, 100 + Math.random() * 200);
      }

      function scheduleNextGlitch() {
        setTimeout(() => triggerGlitch(true, true), 800 + Math.random() * 1700);
      }

      container.addEventListener('mousemove', () => triggerGlitch(false, false));
      setTimeout(scheduleNextGlitch, 5500);

      // ===================
      // WEBGL VISUALS
      // ===================
      const canvas = document.getElementById('psychedelic-canvas');
      const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');

      function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        gl.viewport(0, 0, canvas.width, canvas.height);
      }
      resize();
      window.addEventListener('resize', resize);

      // Utility: random in range
      const rand = (min, max) => min + Math.random() * (max - min);

      // Vertex shader - full screen quad
      const vertexShaderSource = `
        attribute vec2 a_position;
        varying vec2 v_uv;
        void main() {
          v_uv = a_position * 0.5 + 0.5;
          gl_Position = vec4(a_position, 0.0, 1.0);
        }
      `;

      // Common GLSL functions
      const glslCommon = `
        precision highp float;
        varying vec2 v_uv;
        uniform float u_time;
        uniform vec2 u_resolution;

        vec3 hsv2rgb(vec3 c) {
          vec4 K = vec4(1.0, 2.0/3.0, 1.0/3.0, 3.0);
          vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
          return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
        }

        float noise(vec2 p) {
          return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);
        }

        float smoothNoise(vec2 p) {
          vec2 i = floor(p);
          vec2 f = fract(p);
          f = f * f * (3.0 - 2.0 * f);
          return mix(
            mix(noise(i), noise(i + vec2(1.0, 0.0)), f.x),
            mix(noise(i + vec2(0.0, 1.0)), noise(i + vec2(1.0, 1.0)), f.x),
            f.y
          );
        }

        float fbm(vec2 p, int octaves) {
          float v = 0.0, a = 0.5;
          mat2 rot = mat2(0.8, 0.6, -0.6, 0.8);
          for (int i = 0; i < 6; i++) {
            if (i >= octaves) break;
            v += a * smoothNoise(p);
            p = rot * p * 2.0;
            a *= 0.5;
          }
          return v;
        }
      `;

      // Effect configurations with parameters
      const effects = {
        kaleidoscope: {
          params: () => ({
            segments: Math.floor(rand(4, 12)),
            zoom: rand(2, 5),
            speed: rand(0.1, 0.5),
            colorSpeed: rand(0.05, 0.2),
            saturation: rand(0.6, 1.0)
          }),
          shader: `
            ${glslCommon}
            uniform float u_segments;
            uniform float u_zoom;
            uniform float u_speed;
            uniform float u_colorSpeed;
            uniform float u_saturation;

            void main() {
              vec2 uv = v_uv - 0.5;
              uv.x *= u_resolution.x / u_resolution.y;

              float angle = atan(uv.y, uv.x);
              float dist = length(uv);

              float segAngle = 6.28318 / u_segments;
              angle = abs(mod(angle + 3.14159, segAngle) - segAngle * 0.5);

              vec2 p = vec2(cos(angle), sin(angle)) * dist * u_zoom + u_time * u_speed;
              float v = fbm(p, 4);

              vec3 col = hsv2rgb(vec3(v + u_time * u_colorSpeed, u_saturation, 0.6));
              gl_FragColor = vec4(col, 1.0);
            }
          `
        },

        plasma: {
          params: () => ({
            scale: rand(6, 14),
            speed: rand(0.7, 1.5),
            complexity: rand(0.5, 1.0),
            colorSpeed: rand(0.03, 0.1),
            saturation: rand(0.7, 1.0)
          }),
          shader: `
            ${glslCommon}
            uniform float u_scale;
            uniform float u_speed;
            uniform float u_complexity;
            uniform float u_colorSpeed;
            uniform float u_saturation;

            void main() {
              vec2 uv = v_uv * u_scale;
              float t = u_time * u_speed;

              float v1 = sin(uv.x + t);
              float v2 = sin(uv.y + t * 1.1);
              float v3 = sin((uv.x + uv.y) * u_complexity + t);
              float v4 = sin(length(uv - u_scale * 0.5) * u_complexity - t);
              float v = (v1 + v2 + v3 + v4) * 0.25;

              vec3 col = hsv2rgb(vec3(v * 0.5 + 0.5 + u_time * u_colorSpeed, u_saturation, 0.55));
              gl_FragColor = vec4(col, 1.0);
            }
          `
        },

        tunnel: {
          params: () => ({
            spiralFreq: Math.floor(rand(3, 7)),
            zoomSpeed: rand(1, 4),
            twist: rand(0.5, 2.0),
            colorSpeed: rand(0.05, 0.15),
            brightness: 0.65
          }),
          shader: `
            ${glslCommon}
            uniform float u_spiralFreq;
            uniform float u_zoomSpeed;
            uniform float u_twist;
            uniform float u_colorSpeed;
            uniform float u_brightness;

            void main() {
              vec2 uv = v_uv - 0.5;
              uv.x *= u_resolution.x / u_resolution.y;

              float dist = length(uv) + 0.001;
              float angle = atan(uv.y, uv.x);

              // Normalize angle to 0-1 range for seamless wrapping
              float tu = (angle + 3.14159) / 6.28318;
              float tv = 1.0 / dist + u_time * u_zoomSpeed;

              // Use integer frequency to ensure seamless wrap around circle
              float pattern = sin(tu * 6.28318 * u_spiralFreq + u_time * u_twist) * sin(tv * 2.0);

              // Integer multiplier for hue to wrap seamlessly
              float hue = fract(tu * u_spiralFreq + tv * 0.1 + u_time * u_colorSpeed);

              vec3 col = hsv2rgb(vec3(hue, 0.85, u_brightness + pattern * 0.2));
              gl_FragColor = vec4(col, 1.0);
            }
          `
        },

        flowfield: {
          params: () => ({
            scale: rand(2, 5),
            flowSpeed: rand(0.05, 0.2),
            advectStrength: rand(0.05, 0.15),
            colorSpeed: rand(0.03, 0.08),
            saturation: rand(0.7, 1.0)
          }),
          shader: `
            ${glslCommon}
            uniform float u_scale;
            uniform float u_flowSpeed;
            uniform float u_advectStrength;
            uniform float u_colorSpeed;
            uniform float u_saturation;

            void main() {
              vec2 uv = v_uv;
              uv.x *= u_resolution.x / u_resolution.y;

              vec2 p = uv * u_scale;
              for (int i = 0; i < 8; i++) {
                float angle = fbm(p + u_time * u_flowSpeed, 5) * 6.28318;
                p -= vec2(cos(angle), sin(angle)) * u_advectStrength;
              }

              float v = fbm(p, 5);
              vec3 col = hsv2rgb(vec3(v + u_time * u_colorSpeed, u_saturation, 0.6));
              gl_FragColor = vec4(col, 1.0);
            }
          `
        },

        waves: {
          params: () => ({
            frequency: rand(20, 50),
            speed: rand(2, 5),
            numSources: Math.floor(rand(3, 6)),
            colorSpeed: rand(0.03, 0.08),
            saturation: rand(0.7, 1.0)
          }),
          shader: `
            ${glslCommon}
            uniform float u_frequency;
            uniform float u_speed;
            uniform float u_numSources;
            uniform float u_colorSpeed;
            uniform float u_saturation;

            void main() {
              vec2 uv = v_uv;
              uv.x *= u_resolution.x / u_resolution.y;

              float v = 0.0;
              for (int i = 0; i < 6; i++) {
                if (float(i) >= u_numSources) break;
                float fi = float(i);
                vec2 source = vec2(
                  0.5 + 0.3 * cos(fi * 2.1 + 0.5),
                  0.5 + 0.3 * sin(fi * 1.7 + 0.3)
                );
                source.x *= u_resolution.x / u_resolution.y;
                v += sin(length(uv - source) * u_frequency - u_time * u_speed + fi * 1.047);
              }
              v /= u_numSources;

              vec3 col = hsv2rgb(vec3(v * 0.5 + 0.5 + u_time * u_colorSpeed, u_saturation, 0.5 + v * 0.2));
              gl_FragColor = vec4(col, 1.0);
            }
          `
        },

        fractal: {
          params: () => ({
            rotSpeed: rand(0.08, 0.15),
            zoomBase: rand(1.25, 1.75),
            zoomAmt: rand(0.15, 0.3),
            zoomSpeed: rand(0.04, 0.08),
            colorSpeed: rand(0.02, 0.04),
            maxIter: 200
          }),
          shader: `
            ${glslCommon}
            uniform float u_rotSpeed;
            uniform float u_zoomBase;
            uniform float u_zoomAmt;
            uniform float u_zoomSpeed;
            uniform float u_colorSpeed;
            uniform float u_maxIter;

            void main() {
              // Looping zoom (boomerang)
              float zoom = u_zoomBase + u_zoomAmt * sin(u_time * u_zoomSpeed);

              vec2 uv = (v_uv - 0.5) * zoom;
              uv.x *= u_resolution.x / u_resolution.y;

              // Rotate view continuously - creates hypnotic spiral effect
              float angle = u_time * u_rotSpeed;
              float ca = cos(angle), sa = sin(angle);
              uv = vec2(uv.x * ca - uv.y * sa, uv.x * sa + uv.y * ca);

              // Beautiful spiral Julia set - "Douady rabbit" region
              // c oscillates slightly for variety while staying in spiral zone
              vec2 c = vec2(
                -0.75 + 0.02 * sin(u_time * 0.03),
                 0.11 + 0.02 * cos(u_time * 0.04)
              );

              vec2 z = uv;

              float iter = 0.0;
              for (int i = 0; i < 200; i++) {
                if (float(i) >= u_maxIter || dot(z, z) > 4.0) break;
                z = vec2(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y) + c;
                iter += 1.0;
              }

              float t = iter / u_maxIter;
              if (iter < u_maxIter) {
                float log_zn = log(dot(z, z)) / 2.0;
                float nu = log(log_zn / log(2.0)) / log(2.0);
                t = (iter + 1.0 - nu) / u_maxIter;
              }

              // Vibrant colors everywhere - no black ocean
              float hue = t * 2.0 + u_time * u_colorSpeed + 0.55;
              float sat = 0.85 + 0.15 * t;
              float val = 0.5 + 0.5 * t;

              // Inside the set gets a deep color instead of black
              if (iter >= u_maxIter) {
                hue = u_time * u_colorSpeed + 0.7;
                sat = 0.9;
                val = 0.15;
              }

              vec3 col = hsv2rgb(vec3(hue, sat, val));
              gl_FragColor = vec4(col, 1.0);
            }
          `
        },

        voronoi: {
          params: () => ({
            cellCount: Math.floor(rand(8, 20)),
            speed: rand(0.3, 0.8),
            colorSpeed: rand(0.03, 0.08),
            edgeWidth: rand(0.02, 0.06),
            saturation: rand(0.7, 1.0)
          }),
          shader: `
            ${glslCommon}
            uniform float u_cellCount;
            uniform float u_speed;
            uniform float u_colorSpeed;
            uniform float u_edgeWidth;
            uniform float u_saturation;

            void main() {
              vec2 uv = v_uv;
              uv.x *= u_resolution.x / u_resolution.y;
              uv *= u_cellCount;

              float minDist = 10.0;
              float secondMinDist = 10.0;
              float cellId = 0.0;
              vec2 closestPoint;

              for (int y = -1; y <= 1; y++) {
                for (int x = -1; x <= 1; x++) {
                  vec2 neighbor = vec2(float(x), float(y));
                  vec2 cell = floor(uv) + neighbor;

                  // Animate cell centers
                  vec2 point = cell + 0.5 + 0.4 * sin(u_time * u_speed + cell * 3.14159);

                  float dist = length(uv - point);
                  if (dist < minDist) {
                    secondMinDist = minDist;
                    minDist = dist;
                    cellId = noise(cell);
                    closestPoint = point;
                  } else if (dist < secondMinDist) {
                    secondMinDist = dist;
                  }
                }
              }

              float edge = secondMinDist - minDist;
              float edgeLine = 1.0 - smoothstep(0.0, u_edgeWidth, edge);

              float hue = cellId + u_time * u_colorSpeed;
              float val = 0.5 + 0.3 * (1.0 - minDist);

              vec3 col = hsv2rgb(vec3(hue, u_saturation, val));
              col = mix(col, vec3(1.0), edgeLine * 0.8);

              gl_FragColor = vec4(col, 1.0);
            }
          `
        },

        metaballs: {
          params: () => ({
            numBalls: Math.floor(rand(5, 10)),
            threshold: rand(0.8, 1.2),
            speed: rand(0.4, 1.0),
            colorSpeed: rand(0.02, 0.06),
            saturation: rand(0.7, 1.0)
          }),
          shader: `
            ${glslCommon}
            uniform float u_numBalls;
            uniform float u_threshold;
            uniform float u_speed;
            uniform float u_colorSpeed;
            uniform float u_saturation;

            void main() {
              vec2 uv = v_uv - 0.5;
              uv.x *= u_resolution.x / u_resolution.y;

              float sum = 0.0;
              float colorMix = 0.0;

              for (int i = 0; i < 10; i++) {
                if (float(i) >= u_numBalls) break;
                float fi = float(i);

                // Each ball has unique orbit
                vec2 center = vec2(
                  0.3 * sin(u_time * u_speed * (0.7 + fi * 0.1) + fi * 2.1),
                  0.3 * cos(u_time * u_speed * (0.5 + fi * 0.15) + fi * 1.7)
                );

                float radius = 0.08 + 0.04 * sin(fi * 1.5);
                float dist = length(uv - center);
                float influence = radius / (dist + 0.01);
                sum += influence;
                colorMix += influence * fi / u_numBalls;
              }

              colorMix /= sum;

              float v = smoothstep(u_threshold - 0.3, u_threshold + 0.3, sum);
              float edge = smoothstep(u_threshold - 0.1, u_threshold, sum) -
                           smoothstep(u_threshold, u_threshold + 0.1, sum);

              float hue = colorMix + u_time * u_colorSpeed;
              vec3 col = hsv2rgb(vec3(hue, u_saturation, 0.5 + 0.3 * v));
              col += edge * 0.5;

              gl_FragColor = vec4(col, 1.0);
            }
          `
        },

        moire: {
          params: () => ({
            lineFreq: rand(40, 80),
            rotSpeed: rand(0.1, 0.3),
            offset: rand(0.1, 0.3),
            colorSpeed: rand(0.02, 0.06),
            layers: Math.floor(rand(2, 4))
          }),
          shader: `
            ${glslCommon}
            uniform float u_lineFreq;
            uniform float u_rotSpeed;
            uniform float u_offset;
            uniform float u_colorSpeed;
            uniform float u_layers;

            float pattern(vec2 uv, float angle) {
              float c = cos(angle), s = sin(angle);
              vec2 rotUV = vec2(uv.x * c - uv.y * s, uv.x * s + uv.y * c);
              return sin(rotUV.x * u_lineFreq) * 0.5 + 0.5;
            }

            void main() {
              vec2 uv = v_uv - 0.5;
              uv.x *= u_resolution.x / u_resolution.y;

              float v = 0.0;

              for (int i = 0; i < 4; i++) {
                if (float(i) >= u_layers) break;
                float fi = float(i);
                float angle = u_time * u_rotSpeed * (1.0 + fi * 0.3);
                vec2 layerUV = uv + vec2(
                  u_offset * sin(u_time * 0.5 + fi),
                  u_offset * cos(u_time * 0.5 + fi)
                );
                v += pattern(layerUV, angle + fi * 3.14159 / u_layers);
              }
              v /= u_layers;

              // Circular pattern overlay
              float circles = sin(length(uv) * u_lineFreq * 0.5 - u_time) * 0.5 + 0.5;
              v = v * 0.7 + circles * 0.3;

              float hue = v + u_time * u_colorSpeed;
              vec3 col = hsv2rgb(vec3(hue, 0.85, 0.5 + 0.3 * v));

              gl_FragColor = vec4(col, 1.0);
            }
          `
        },

        hyperbolic: {
          params: () => ({
            pValue: Math.floor(rand(4, 8)),
            qValue: Math.floor(rand(4, 8)),
            rotSpeed: rand(0.05, 0.15),
            colorSpeed: rand(0.02, 0.05),
            innerZoom: rand(0.5, 0.8)
          }),
          shader: `
            ${glslCommon}
            uniform float u_pValue;
            uniform float u_qValue;
            uniform float u_rotSpeed;
            uniform float u_colorSpeed;
            uniform float u_innerZoom;

            void main() {
              // Scale UV so disk always fills viewport (account for aspect ratio)
              float aspect = u_resolution.x / u_resolution.y;
              vec2 uv = (v_uv - 0.5) * 2.0;
              uv.x *= aspect;

              // Normalize so max extent maps to innerZoom (less than 1.0 = inside disk)
              float maxExtent = max(aspect, 1.0);
              uv *= u_innerZoom / maxExtent;

              // Rotate the view
              float angle = u_time * u_rotSpeed;
              float c = cos(angle), s = sin(angle);
              uv = vec2(uv.x * c - uv.y * s, uv.x * s + uv.y * c);

              float r = length(uv);

              // Clamp to disk edge (should never hit this now, but just in case)
              r = min(r, 0.999);

              // Create tiling pattern using polar coordinates in hyperbolic space
              float theta = atan(uv.y, uv.x);
              float rho = log((1.0 + r) / (1.0 - r)); // hyperbolic radius

              // Tile based on p,q values
              float pAngle = 6.28318 / u_pValue;
              float qAngle = 6.28318 / u_qValue;

              float tileTheta = mod(theta + 3.14159, pAngle);
              float tileRho = mod(rho + u_time * 0.5, qAngle);

              float pattern = sin(tileTheta * u_pValue * 2.0) * sin(tileRho * u_qValue);

              // Distance to center for coloring
              float hue = rho * 0.2 + theta / 6.28318 + u_time * u_colorSpeed;
              float sat = 0.8 + 0.2 * pattern;
              float val = 0.4 + 0.4 * (1.0 - r) + 0.2 * pattern;

              vec3 col = hsv2rgb(vec3(hue, sat, val));

              // Edge of disk glow
              col += vec3(0.3) * smoothstep(0.8, 1.0, r);

              gl_FragColor = vec4(col, 1.0);
            }
          `
        },

        aurora: {
          params: () => ({
            layers: Math.floor(rand(3, 6)),
            speed: rand(0.2, 0.5),
            waveFreq: rand(2, 5),
            verticalStretch: rand(1.5, 3.0),
            colorSpeed: rand(0.02, 0.05)
          }),
          shader: `
            ${glslCommon}
            uniform float u_layers;
            uniform float u_speed;
            uniform float u_waveFreq;
            uniform float u_verticalStretch;
            uniform float u_colorSpeed;

            void main() {
              vec2 uv = v_uv;
              uv.x *= u_resolution.x / u_resolution.y;

              vec3 col = vec3(0.0);

              for (int i = 0; i < 6; i++) {
                if (float(i) >= u_layers) break;
                float fi = float(i);

                // Each layer has different wave characteristics
                float phase = fi * 0.5 + u_time * u_speed * (1.0 + fi * 0.2);

                // Create curtain-like waves
                float wave = 0.0;
                wave += sin(uv.x * u_waveFreq + phase) * 0.15;
                wave += sin(uv.x * u_waveFreq * 2.3 + phase * 1.3) * 0.08;
                wave += sin(uv.x * u_waveFreq * 0.7 + phase * 0.7) * 0.12;

                // Vertical position of this curtain
                float curtainY = 0.3 + fi * 0.12 + wave;

                // Brightness based on distance to curtain
                float dist = abs(uv.y - curtainY);
                float brightness = exp(-dist * u_verticalStretch * 4.0);

                // Add shimmer
                brightness *= 0.7 + 0.3 * sin(uv.x * 20.0 + u_time * 2.0 + fi);

                // Color gradient - greens, blues, purples
                float hue = 0.4 + fi * 0.08 + uv.x * 0.1 + u_time * u_colorSpeed;
                vec3 layerCol = hsv2rgb(vec3(hue, 0.7, brightness));

                col += layerCol * (1.0 - fi / u_layers * 0.5);
              }

              // Add subtle background stars
              float stars = step(0.998, noise(uv * 500.0)) * 0.3;
              col += vec3(stars);

              gl_FragColor = vec4(col, 1.0);
            }
          `
        },

        electric: {
          params: () => ({
            branches: Math.floor(rand(5, 9)),
            speed: rand(0.3, 0.8),
            intensity: rand(0.6, 1.0),
            thickness: rand(0.025, 0.045),
            colorSpeed: rand(0.02, 0.06)
          }),
          shader: `
            ${glslCommon}
            uniform float u_branches;
            uniform float u_speed;
            uniform float u_intensity;
            uniform float u_thickness;
            uniform float u_colorSpeed;

            float lightning(vec2 uv, float seed, float time, vec2 center, float angle) {
              float line = 0.0;

              // Calculate start and end points based on angle
              float len = 0.8;
              vec2 dir = vec2(cos(angle), sin(angle));
              vec2 start = center + dir * len;
              vec2 end = center - dir * len;

              float segments = 16.0;
              vec2 pos = start;

              // Perpendicular direction for offsets
              vec2 perp = vec2(-dir.y, dir.x);

              for (float i = 0.0; i < 16.0; i++) {
                vec2 nextPos = mix(start, end, (i + 1.0) / segments);

                // Smooth wandering offset using sine waves
                float t1 = time * u_speed + i * 0.7 + seed;
                float t2 = time * u_speed * 0.7 + i * 1.1 + seed * 2.0;
                float offset = sin(t1) * 0.15 + sin(t2 * 1.7) * 0.1;
                offset *= (1.0 - i / segments) * (0.3 + i / segments);

                nextPos += perp * offset;

                // Distance to line segment
                vec2 pa = uv - pos;
                vec2 ba = nextPos - pos;
                float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);
                float d = length(pa - ba * h);

                // Soft glow
                line += u_thickness / (d + 0.002) * 0.015;

                pos = nextPos;
              }

              return line * u_intensity;
            }

            void main() {
              vec2 uv = v_uv;
              uv.x *= u_resolution.x / u_resolution.y;

              float t = u_time;
              vec3 col = vec3(0.0);

              float aspect = u_resolution.x / u_resolution.y;

              for (int i = 0; i < 9; i++) {
                if (float(i) >= u_branches) break;
                float fi = float(i);

                // Random angle for each branch (0 to 2*PI)
                float angle = noise(vec2(fi * 17.3, 42.7)) * 6.28318;

                // Distribute centers across viewport
                vec2 center = vec2(
                  (fi + 0.5) / u_branches * aspect,
                  0.5
                );
                // Add gentle drift
                center += vec2(
                  sin(fi * 2.5 + t * 0.1) * 0.04,
                  cos(fi * 1.8 + t * 0.08) * 0.03
                );

                // Smooth pulsing intensity instead of harsh flicker
                float pulse = 0.6 + 0.4 * sin(t * 0.8 + fi * 1.5);
                pulse *= 0.7 + 0.3 * sin(t * 1.3 + fi * 2.7);

                float bolt = lightning(uv, fi * 13.7, t + fi * 0.5, center, angle) * pulse;

                // Color gradient - vivid electric blues and purples
                float hue = 0.58 + fi * 0.035 + sin(t * 0.2) * 0.05 + u_time * u_colorSpeed;
                vec3 boltCol = hsv2rgb(vec3(hue, 0.9, 1.0));

                col += bolt * boltCol;
              }

              // Softer gamma
              col = pow(col, vec3(0.7));

              // Subtle ambient glow
              float ambientPulse = 0.02 + 0.01 * sin(t * 0.5);
              col += vec3(ambientPulse * 0.8, ambientPulse * 0.4, ambientPulse * 1.2);

              gl_FragColor = vec4(col, 1.0);
            }
          `
        },

        reaction: {
          params: () => ({
            scale: rand(5, 12),
            warpIntensity: rand(2, 6),
            speed: rand(0.2, 0.5),
            colorSpeed: rand(0.01, 0.04),
            saturation: rand(0.7, 0.95)
          }),
          shader: `
            ${glslCommon}
            uniform float u_scale;
            uniform float u_warpIntensity;
            uniform float u_speed;
            uniform float u_colorSpeed;
            uniform float u_saturation;

            void main() {
              vec2 uv = v_uv * u_scale;

              float t = u_time * u_speed;
              vec2 q = vec2(fbm(uv + t, 6), fbm(uv + vec2(5.2, 1.3) + t, 6));
              vec2 r = vec2(
                fbm(uv + u_warpIntensity * q + vec2(1.7, 9.2) + t * 0.5, 6),
                fbm(uv + u_warpIntensity * q + vec2(8.3, 2.8) + t * 0.5, 6)
              );

              float v = fbm(uv + u_warpIntensity * r, 6);

              vec3 col = hsv2rgb(vec3(v * 0.5 + u_time * u_colorSpeed, u_saturation, 0.55));
              gl_FragColor = vec4(col, 1.0);
            }
          `
        }
      };

      // Compile shader
      function compileShader(source, type) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
          console.error('Shader error:', gl.getShaderInfoLog(shader));
          return null;
        }
        return shader;
      }

      // Create program
      function createProgram(fragSource) {
        const vertShader = compileShader(vertexShaderSource, gl.VERTEX_SHADER);
        const fragShader = compileShader(fragSource, gl.FRAGMENT_SHADER);
        const program = gl.createProgram();
        gl.attachShader(program, vertShader);
        gl.attachShader(program, fragShader);
        gl.linkProgram(program);
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
          console.error('Program error:', gl.getProgramInfoLog(program));
          return null;
        }
        return program;
      }

      // Create full-screen quad
      const posBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, posBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
        -1, -1, 1, -1, -1, 1,
        -1, 1, 1, -1, 1, 1
      ]), gl.STATIC_DRAW);

      // Compile all programs
      const programs = {};
      for (const name in effects) {
        programs[name] = createProgram(effects[name].shader);
      }

      // Pick effect - use last effect if debug mode, otherwise random
      const effectNames = Object.keys(effects);
      const debugModeStored = localStorage.getItem('dream-debug') === 'true';
      const lastEffect = localStorage.getItem('dream-effect');

      let currentEffect;
      if (debugModeStored && lastEffect && effects[lastEffect]) {
        currentEffect = lastEffect;
      } else {
        currentEffect = effectNames[Math.floor(Math.random() * effectNames.length)];
      }
      localStorage.setItem('dream-effect', currentEffect);

      let currentParams = effects[currentEffect].params();
      let program = programs[currentEffect];

      const startTime = performance.now();

      // Debug mode
      const debugEl = document.getElementById('debug');
      const debugContent = document.getElementById('debug-content');
      let debugMode = localStorage.getItem('dream-debug') === 'true';
      let frameCount = 0;
      let lastFpsTime = performance.now();
      let fps = 0;
      let selectedParamIndex = 0;

      debugEl.style.display = debugMode ? 'block' : 'none';

      function switchEffect(name) {
        if (effects[name] && programs[name]) {
          currentEffect = name;
          currentParams = effects[name].params();
          program = programs[name];
          selectedParamIndex = 0;
          localStorage.setItem('dream-effect', name);
        }
      }

      function adjustParam(delta) {
        const keys = Object.keys(currentParams);
        if (keys.length === 0) return;
        const key = keys[selectedParamIndex];
        const value = currentParams[key];
        if (typeof value === 'number') {
          // Adjust by ~10% of current value, with sensible minimums
          let step;
          if (Math.abs(value) < 0.001) {
            step = 0.0002;
          } else if (Math.abs(value) < 0.01) {
            step = 0.001;
          } else if (Math.abs(value) < 0.1) {
            step = 0.005;
          } else if (Math.abs(value) < 1) {
            step = 0.02;
          } else {
            step = Math.abs(value) * 0.05;
          }
          currentParams[key] = value + step * delta;
        }
      }

      document.addEventListener('keydown', (e) => {
        if (e.key === '`' || e.key === '~') {
          debugMode = !debugMode;
          debugEl.style.display = debugMode ? 'block' : 'none';
          localStorage.setItem('dream-debug', debugMode);
          return;
        }

        if (!debugMode) return;

        const keys = Object.keys(currentParams);

        // Number keys to switch effects (1-9 for 1-9, 0 for 10)
        if (e.key >= '0' && e.key <= '9') {
          const num = e.key === '0' ? 10 : parseInt(e.key);
          const effectName = effectNames[num - 1];
          if (effectName) switchEffect(effectName);
          return;
        }

        // n/p to cycle through effects
        if (e.key === 'n' || e.key === 'N') {
          const idx = (effectNames.indexOf(currentEffect) + 1) % effectNames.length;
          switchEffect(effectNames[idx]);
          return;
        }
        if (e.key === 'p' || e.key === 'P') {
          const idx = (effectNames.indexOf(currentEffect) - 1 + effectNames.length) % effectNames.length;
          switchEffect(effectNames[idx]);
          return;
        }

        // Arrow keys to navigate and adjust params
        switch (e.key) {
          case 'ArrowUp':
            selectedParamIndex = Math.max(0, selectedParamIndex - 1);
            break;
          case 'ArrowDown':
            selectedParamIndex = Math.min(keys.length - 1, selectedParamIndex + 1);
            break;
          case 'ArrowRight':
            adjustParam(1);
            break;
          case 'ArrowLeft':
            adjustParam(-1);
            break;
          case 'r':
          case 'R':
            // Reset params
            currentParams = effects[currentEffect].params();
            break;
        }
      });

      function formatParams(params) {
        const keys = Object.keys(params);
        return keys.map((k, i) => {
            const v = params[k];
            const prefix = debugMode && i === selectedParamIndex ? '> ' : '  ';
            if (typeof v !== 'number') return `${prefix}${k}: ${v}`;
            if (Math.abs(v) < 0.01 && v !== 0) return `${prefix}${k}: ${v.toExponential(2)}`;
            return `${prefix}${k}: ${v.toFixed(3)}`;
          })
          .join('\n');
      }

      function updateDebug(t) {
        frameCount++;
        const now = performance.now();
        if (now - lastFpsTime >= 1000) {
          fps = Math.round(frameCount * 1000 / (now - lastFpsTime));
          frameCount = 0;
          lastFpsTime = now;
        }

        if (debugMode) {
          debugContent.textContent = [
            `effect: ${currentEffect} [1-0, n/p to switch]`,
            `fps: ${fps}`,
            `time: ${t.toFixed(2)}s`,
            `resolution: ${canvas.width}x${canvas.height}`,
            ``,
            `params: [↑↓ select, ←→ adjust, R reset]`,
            formatParams(currentParams)
          ].join('\n');
        }
      }

      function render() {
        const t = (performance.now() - startTime) / 1000;

        gl.useProgram(program);

        // Set common uniforms
        gl.uniform1f(gl.getUniformLocation(program, 'u_time'), t);
        gl.uniform2f(gl.getUniformLocation(program, 'u_resolution'), canvas.width, canvas.height);

        // Set effect-specific uniforms
        for (const [key, value] of Object.entries(currentParams)) {
          const loc = gl.getUniformLocation(program, `u_${key}`);
          if (loc) gl.uniform1f(loc, value);
        }

        // Set attributes
        const posLoc = gl.getAttribLocation(program, 'a_position');
        gl.enableVertexAttribArray(posLoc);
        gl.bindBuffer(gl.ARRAY_BUFFER, posBuffer);
        gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

        // Draw
        gl.drawArrays(gl.TRIANGLES, 0, 6);

        updateDebug(t);
        requestAnimationFrame(render);
      }
      render();
    </script>
  </body>
</html>
